{"name":"AtlasDB","tagline":"Transactional Distributed Database Layer","body":"# AtlasDB\r\nAtlasDB is a transactional layer on top of a key value store.  When designing a\r\ndata store to be scalable, transactions are usually the first feature to be\r\ncut.  However they are one of the most useful features for developers.  AtlasDB\r\nallows any key value store that supports durable writes to have transactions.\r\nOnce you have transactions, indexes are also easy to add because updates to\r\nrows can just update the indexes and include those writes in a single\r\ntransaction.  Provided are KeyValueService implementations of LevelDB and\r\nCassandra, but any data store worth its salt should make a fine storage layer.\r\n\r\n# Consistency\r\nAtlasDB uses classic MVCC and supports Snapshot Isolation and Serializable\r\nSnapshot Isolation.  SI must keep track of the write set in memory to detect\r\nwrite/write conflicts.  SSI must also keep the read set in memory to detect\r\nread/write conflicts.  This means that write transactions are expected to be\r\nreasonably short lived.  Read-only transactions are allowed to run for longer\r\nand will never conflict with other transactions.\r\n\r\n# Schemas\r\nAtlasDB can store keys and values using atlasdb-api directly, but using Schemas can\r\nget you type safely, more readable code and remove a lot of boilerplate\r\nserialization code.  AtlasDB contains a Java DSL to define schemas and a proto\r\nrepresentation that gets stored in the K/V store that can be used by other\r\ntools to inspect the values.  Schema tables can be rendered to Java classes to\r\neasily access tables and keep indexes up to date given the schema.\r\n\r\n# Wiki\r\nMake sure to check out the wiki for more details: [https://github.com/palantir/atlasdb/wiki](https://github.com/palantir/atlasdb/wiki)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}