<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>AtlasDB by palantir</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="css/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="css/index-stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="css/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">AtlasDB</h1>
      <h2 class="project-tagline">Transactional Distributed Database Layer</h2>
      <a href="https://github.com/palantir/atlasdb" class="btn">View on GitHub</a>
      <a href="html/index.html" class="btn">View Docs</a>
      <a href="https://github.com/palantir/atlasdb/releases" class="btn">View Releases</a>
    </section>

    <section class="main-content">
      <h1>
<a id="atlasdb" class="anchor" href="#atlasdb" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>AtlasDB</h1>

<p>AtlasDB is a transactional layer on top of a key value store.  When designing a
data store to be scalable, transactions are usually the first feature to be
cut.  However they are one of the most useful features for developers.  AtlasDB
allows any key value store that supports durable writes to have transactions.
Once you have transactions, indexes are also easy to add because updates to
rows can just update the indexes and include those writes in a single
transaction.  Provided are KeyValueService implementations of LevelDB and
Cassandra, but any data store worth its salt should make a fine storage layer.</p>

<h1>
<a id="consistency" class="anchor" href="#consistency" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Consistency</h1>

<p>AtlasDB uses classic MVCC and supports Snapshot Isolation and Serializable
Snapshot Isolation.  SI must keep track of the write set in memory to detect
write/write conflicts.  SSI must also keep the read set in memory to detect
read/write conflicts.  This means that write transactions are expected to be
reasonably short lived.  Read-only transactions are allowed to run for longer
and will never conflict with other transactions.</p>

<h1>
<a id="schemas" class="anchor" href="#schemas" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Schemas</h1>

<p>AtlasDB can store keys and values using atlasdb-api directly, but using Schemas can
get you type safety, more readable code and remove a lot of boilerplate
serialization code.  AtlasDB contains a Java DSL to define schemas and a proto
representation that gets stored in the K/V store that can be used by other
tools to inspect the values.  Schema tables can be rendered to Java classes to
easily access tables and keep indexes up to date given the schema.</p>

<h1>
<a id="wiki" class="anchor" href="#wiki" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Learn More</h1>
<p>Check out <a href="html/index.html">the documentation</a> for more details.</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/palantir/atlasdb">AtlasDB</a> is maintained by <a href="https://github.com/palantir">palantir</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  </body>
</html>
